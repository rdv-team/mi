
#Область Примеры

// Пример 1: Многопоточная обработка массива данных.
//
// - Процедура "ИмяМодуля.ИмяПроцедуры" - обработчик запускаемых фоновых заданий,
// 	в качестве первого аргумента принимает элементы массива данных.
//  - ЧислоПотоков - ограничение количества одновременно запускаемых фоновых заданий.
// - РазмерПорции - максимальный размер массива из элементов входящих в "МассивДанных",
// 	который может быть передан на обработку в процедуру.
// - МассивДанных - передается по частям в указанную процедуру равномерно
// 	с учетом ограничения по числу параллельных потоков и размеров порций.
//
// Задание = рдв_Многопоточность.НовоеЗадание("ИмяМодуля.ИмяПроцедуры", МассивДанных);
// рдв_Многопоточность.ВыполнитьЗадание(Задание);


// Пример 2: Многопоточная обработка массива данных с возвратом результата обработки.
// При создании задания необходимо явно описать параметры процедуры "АдресРезультата".
//
// - Процедура "ИмяМодуля.ИмяПроцедуры" с аргументами (Массив, АдресРезультата).
//
// ОписаниеПараметров = рдв_Многопоточность.НовоеОписаниеПараметров();
// рдв_Многопоточность.ДобавитьПараметр(ОписаниеПараметров, "КлючиДанных",,, Истина);
// рдв_Многопоточность.ДобавитьПараметр(ОписаниеПараметров, "АдресРезультата",,,, Истина);
//
// Задание = рдв_Многопоточность.НовоеЗадание(
// 	"ИмяМодуля.ИмяПроцедуры", КлючиДанных, МаксЧислоПотоков, МаксРазмерПорции, ОписаниеПараметров
// );
//
// рдв_Многопоточность.ВыполнитьЗадание(Задание);
//
// Для Каждого Поток Из Задание.ВсеПотоки Цикл
// 	РезультатОбработкиПотока = Поток.Результат;
// 	<Код обработки результата>
// КонецЦикла;

#КонецОбласти

#Область ПрограммныйИнтерфейс

Функция ВыполнитьКод(ТекстКода, КоллекцияДанных, ДополнительныеПараметры = Неопределено, ЧислоПотоков = 4, РазмерПорции = 1,
	РазделителиДанных = Неопределено, Наименование = "", ИдентификаторЗадания = Неопределено, Таймаут = 60) Экспорт
	
	ОписаниеПараметров = НовоеОписаниеПараметров();
	ДобавитьПараметр(ОписаниеПараметров, "ТекстКода", ТекстКода);
	ДобавитьПараметр(ОписаниеПараметров, "КоллекцияДанных",,, Истина);
	ДобавитьПараметр(ОписаниеПараметров, "ДополнительныеПараметры", ДополнительныеПараметры);
	ДобавитьПараметр(ОписаниеПараметров, "АдресРезультата",,,, Истина);
	
	Задание = НовоеЗадание("рдв_Многопоточность.ВыполнитьКод_Служебная", КоллекцияДанных, ЧислоПотоков, РазмерПорции, ОписаниеПараметров,
		РазделителиДанных, Наименование, ИдентификаторЗадания, Таймаут
	);
	
	Возврат ВыполнитьЗадание(Задание);
		
КонецФункции

Функция НовоеЗадание(ИмяМетода, КоллекцияДанных, ЧислоПотоков = 4, РазмерПорции = 1, ОписаниеПараметров = Неопределено, 
	РазделителиДанных = Неопределено, Наименование = "", ИдентификаторЗадания = Неопределено, Таймаут = 60) Экспорт
	
	// Идентификатор используется для возврата результатов выполнения заданий.
	Если Не ЗначениеЗаполнено(ИдентификаторЗадания) Тогда 
		ИдентификаторЗадания = Новый УникальныйИдентификатор;
	КонецЕсли;
	
	// Использование возврата результатов выполнения заданий.
	ИспользуютсяРезультатыЗаданий = (ОписаниеПараметров <> Неопределено)
	И ОписаниеПараметров.Найти(Истина, "ЭтоАдресРезультата") <> Неопределено;
	
	Если ПустаяСтрока(Наименование) Тогда
		Наименование = ИмяМетода;
	КонецЕсли;
	
	Если ОписаниеПараметров = Неопределено Тогда
		ОписаниеПараметров = НовоеОписаниеПараметров();
		ДобавитьПараметр(ОписаниеПараметров,,,, Истина);
	КонецЕсли;
	
	ИспользуютсяРазделителиДанных = Не ПустаяСтрока(РазделителиДанных);

	Задание = Новый Структура;
	Задание.Вставить("ИмяМетода", ИмяМетода);
	Задание.Вставить("Наименование", Наименование);
	Задание.Вставить("ЧислоПотоков", ЧислоПотоков);
	Задание.Вставить("РазмерПорции", РазмерПорции);
	Задание.Вставить("КоличествоДанных", КоллекцияДанных.Количество());
	Задание.Вставить("КоллекцияДанных", КоллекцияДанных);
	Задание.Вставить("РазделителиДанных", РазделителиДанных);
	Задание.Вставить("ОписаниеПараметров", ОписаниеПараметров);
	Задание.Вставить("ФоновыеЗадания", Новый Массив);
	Задание.Вставить("ВсеПотоки", НовоеОписаниеПотоков());
	Задание.Вставить("НовыеПотоки", Новый Массив);
	Задание.Вставить("ИзмененныеПотоки", Новый Массив);
	Задание.Вставить("АктивныеПотоки", Новый Массив);
	Задание.Вставить("ВыполненныеПотоки", Новый Массив);
	Задание.Вставить("ПотокиСОшибками", Новый Массив);
	Задание.Вставить("ОтмененныеПотоки", Новый Массив);
	Задание.Вставить("КоличествоВыполненныхПотоков", 0);
	Задание.Вставить("КоличествоПотоковСОшибками", 0);
	Задание.Вставить("КоличествоОтмененныхПотоков", 0);
	Задание.Вставить("ИдентификаторЗадания", ИдентификаторЗадания);
	Задание.Вставить("Таймаут", Таймаут);
	Задание.Вставить("ИспользуютсяРезультатыЗаданий", ИспользуютсяРезультатыЗаданий);
	Задание.Вставить("ИспользуютсяРазделителиДанных", ИспользуютсяРазделителиДанных);
	
	ПоказателиПорций = РассчитатьПоказателиПорций(Задание.КоличествоДанных, ЧислоПотоков, РазмерПорции);
	Задание.Вставить("РасчетноеОбщееКоличествоПотоков", ПоказателиПорций.КоличествоПорций);
	
	Если Не ИспользуютсяРазделителиДанных Тогда
		// Без разделителей: ПоследовательноеНаполнение, ПараллельноеНаполнение.
		Задание.Вставить("РасчетПорций", "ПоследовательноеНаполнение");
	Иначе
		// С разделителями: РазделительВОднойПорции.
		Задание.Вставить("РасчетПорций", "РазделительВОднойПорции");
	КонецЕсли;

	// ОбработкаДанных - таблица используется для регистрации состояния обработки данных
	// для побора в новый поток только невзятых в обработку даннных, также для заверешения
	// процесса формирования новых потоков, когда не остается данных "К обработке".
	ОбработкаДанных = Новый ТаблицаЗначений;
	ОбработкаДанных.Колонки.Добавить("ИндексДанных");
	ОбработкаДанных.Колонки.Добавить("ЭлементДанных");
	ОбработкаДанных.Колонки.Добавить("НомерПотока");
	ОбработкаДанных.Колонки.Добавить("ИндексРазделителя");
	
	// Разделители используются для разделения данных между потоками таким образом,
	// чтобы в разные потоки не попадали данные с одним и тем же разделителем.
	// Значения полей-разделителей индексируются по таблице разделителей, индексы
	// разделителей используются в таблице "ОбработкаДанных" в колонке "ИндексРазделителя".
	Задание.Вставить("ЗначенияРазделителей");
	СтруктураРазделителей = Неопределено;
	Если ИспользуютсяРазделителиДанных Тогда
		ЗначенияРазделителей = Новый ТаблицаЗначений;
		СтруктураРазделителей = Новый Структура(РазделителиДанных);
		Для Каждого ЭлементРазделитель Из СтруктураРазделителей Цикл
			ЗначенияРазделителей.Колонки.Добавить(ЭлементРазделитель.Ключ);
		КонецЦикла;     
		Для Каждого ЭлементДанных Из КоллекцияДанных Цикл
			ЗаполнитьЗначенияСвойств(ЗначенияРазделителей.Добавить(), ЭлементДанных, РазделителиДанных);
		КонецЦикла;
		ЗначенияРазделителей.Свернуть(РазделителиДанных);
		ЗначенияРазделителей.Индексы.Добавить(РазделителиДанных);
		Задание.ЗначенияРазделителей = ЗначенияРазделителей;
	КонецЕсли;
	
	// КОбработке, Обрбатывается, Обработано, ОбработаноСОшибкой, Отменено.
	ОбработкаДанных.Колонки.Добавить("Состояние");
	
	// Инициализация таблицы "ОбработкаДанных".
	Для ИндексДанных = 0 По Задание.КоличествоДанных - 1 Цикл
		НоваяСтрока = ОбработкаДанных.Добавить();
		НоваяСтрока.ИндексДанных = ИндексДанных;
		НоваяСтрока.Состояние = "КОбработке";
		НоваяСтрока.ЭлементДанных = КоллекцияДанных[ИндексДанных];
		Если ИспользуютсяРазделителиДанных Тогда
			ЗаполнитьЗначенияСвойств(СтруктураРазделителей, НоваяСтрока.ЭлементДанных);
			СтрокиРазделителя = ЗначенияРазделителей.НайтиСтроки(СтруктураРазделителей);
			Если СтрокиРазделителя.Количество() > 0 Тогда
				НоваяСтрока.ИндексРазделителя = ЗначенияРазделителей.Индекс(СтрокиРазделителя[0]);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Задание.Вставить("ОбработкаДанных", ОбработкаДанных);

	Возврат Задание;
	
КонецФункции

Функция ВыполнитьЗадание(Задание) Экспорт
	Пока СледующиеПотокиЗадания(Задание) Цикл
		ЗапуститьИОжидатьВыполненияПотоков(Задание);
	КонецЦикла;
	ОжидатьВыполненияПотоков(Задание, Истина);
	Возврат Задание.ВсеПотоки;
КонецФункции

Функция НовоеОписаниеПараметров() Экспорт
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Имя");
	Таблица.Колонки.Добавить("Значение");
	Таблица.Колонки.Добавить("ПолеДанных");
	Таблица.Колонки.Добавить("ЭтоМассивИзДанных", Новый ОписаниеТипов("Булево"));
	Таблица.Колонки.Добавить("ЭтоАдресРезультата", Новый ОписаниеТипов("Булево"));
	Возврат Таблица;
КонецФункции

Функция ДобавитьПараметр(ОписаниеПараметров, Имя = "", Значение = Неопределено, ПолеДанных = "",
	ЭтоМассивИзДанных = Ложь, ЭтоАдресРезультата = Ложь) Экспорт
	
	НоваяСтрока = ОписаниеПараметров.Добавить();
	НоваяСтрока.Имя = Имя;
	НоваяСтрока.Значение = Значение;
	НоваяСтрока.ПолеДанных = ПолеДанных;
	НоваяСтрока.ЭтоМассивИзДанных = ЭтоМассивИзДанных;
	НоваяСтрока.ЭтоАдресРезультата = ЭтоАдресРезультата;
	Возврат НоваяСтрока;
КонецФункции

Функция СледующиеПотокиЗадания(Задание) Экспорт
	
	Задание.НовыеПотоки.Очистить();
	
	МассивЗаданий = Задание.ФоновыеЗадания;
	
	КоличествоКЗапуску = Задание.ЧислоПотоков - МассивЗаданий.Количество();
	Если КоличествоКЗапуску <= 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	ОтборДанныхКОбработке = Новый Структура("Состояние", "КОбработке");
	ДанныеКОбработке = Задание.ОбработкаДанных.НайтиСтроки(ОтборДанныхКОбработке);
	Если ДанныеКОбработке.Количество() = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	//++ Расчет порций
	Если Не Задание.ИспользуютсяРазделителиДанных Тогда
		Если Задание.РасчетПорций = "ПоследовательноеНаполнение" Тогда
			ОписаниеПорций = РассчитатьПорцииДанных_ПоследовательноеНаполнение(ДанныеКОбработке, КоличествоКЗапуску, Задание.РазмерПорции);
		ИначеЕсли Задание.РасчетПорций = "ПараллельноеНаполнение" Тогда
			ОписаниеПорций = РассчитатьПорцииДанных_ПараллельноеНаполнение(ДанныеКОбработке, КоличествоКЗапуску, Задание.РазмерПорции);
		Иначе
			ОписаниеПорций = РассчитатьПорцииДанных_ПоследовательноеНаполнение(ДанныеКОбработке, КоличествоКЗапуску, Задание.РазмерПорции);
		КонецЕсли;
			
	Иначе
		Если Задание.РасчетПорций = "РазделительВОднойПорции" Тогда
			ОписаниеПорций = РассчитатьПорцииДанных_РазделительВОднойПорции(ДанныеКОбработке, КоличествоКЗапуску, Задание.РазмерПорции, "ИндексРазделителя");
		Иначе
			ОписаниеПорций = РассчитатьПорцииДанных_РазделительВОднойПорции(ДанныеКОбработке, КоличествоКЗапуску, Задание.РазмерПорции, "ИндексРазделителя");
		КонецЕсли;
	КонецЕсли;
	//-- Расчет порций
	
	// Порция.Данные - содержит массив строк таблицы "ОбработкаДанных".
	Для Каждого Порция Из ОписаниеПорций.Порции Цикл
		
		АдресРезультата = Неопределено;
		Если Задание.ИспользуютсяРезультатыЗаданий Тогда
			Если Задание.ИдентификаторЗадания <> Неопределено Тогда
				УникальныйИдентификатор = Задание.ИдентификаторЗадания;
			Иначе
				УникальныйИдентификатор = Новый УникальныйИдентификатор;
			КонецЕсли;
			АдресРезультата = ПоместитьВоВременноеХранилище(Неопределено, УникальныйИдентификатор);
		КонецЕсли;
		
		Параметры = Новый Массив;
		Для Каждого ОписаниеПараметра Из Задание.ОписаниеПараметров Цикл
			Если ОписаниеПараметра.ЭтоАдресРезультата Тогда
				ЗначениеПараметра = АдресРезультата;
			ИначеЕсли Не ПустаяСтрока(ОписаниеПараметра.ПолеДанных) Или ОписаниеПараметра.ЭтоМассивИзДанных Тогда
				// Имя поля элемента коллекции данных для получения значения.
				ПолеДанных = ОписаниеПараметра.ПолеДанных;
				// Использование элемента данных в качестве значения параметра.
				ЭлементДанныхКакЗначение = (ОписаниеПараметра.ПолеДанных = "*")
					Или (ОписаниеПараметра.ПолеДанных = ".")
					Или (ПустаяСтрока(ОписаниеПараметра.ПолеДанных) И ОписаниеПараметра.ЭтоМассивИзДанных)
				;
				Если ОписаниеПараметра.ЭтоМассивИзДанных Тогда
					ЗначениеПараметра = Новый Массив;
					Для Каждого СтрокаОбработкиДанных Из Порция.Данные Цикл
						Если ЭлементДанныхКакЗначение Тогда
							ЗначениеПараметра.Добавить(СтрокаОбработкиДанных.ЭлементДанных);
						Иначе
							ЗначениеПараметра.Добавить(СтрокаОбработкиДанных.ЭлементДанных[ПолеДанных]);
						КонецЕсли;
					КонецЦикла;
				Иначе
					// Получение значения параметра из первой строки обработки данных.
					Если ЭлементДанныхКакЗначение Тогда
						ЗначениеПараметра = Порция.Данные[0].ЭлементДанных;
					Иначе
						ЗначениеПараметра = Порция.Данные[0].ЭлементДанных[ПолеДанных];
					КонецЕсли;
				КонецЕсли;
			Иначе
				// Фиксирование значение параметра.
				ЗначениеПараметра = ОписаниеПараметра.Значение;
			КонецЕсли;
			Параметры.Добавить(ЗначениеПараметра);
		КонецЦикла;
		
		ДанныеПотока = Новый Структура("ИндексыДанных, Данные", Новый Массив, Новый Массив);
		Для Каждого СтрокаОбработкиДанных Из Порция.Данные Цикл
			ДанныеПотока.ИндексыДанных.Добавить(СтрокаОбработкиДанных.ИндексДанных);
			ДанныеПотока.Данные.Добавить(СтрокаОбработкиДанных.ЭлементДанных);
		КонецЦикла;

		НовыйПоток = НовыйПотокЗадания(Задание.ВсеПотоки, ДанныеПотока, Параметры, АдресРезультата); 
		Задание.НовыеПотоки.Добавить(НовыйПоток);
		
		Для Каждого СтрокаОбработкиДанных Из Порция.Данные Цикл
			СтрокаОбработкиДанных.НомерПотока = НовыйПоток.НомерПотока;
		КонецЦикла;
				
	КонецЦикла;
	
	Возврат Истина;
		
КонецФункции

Функция ЗапуститьИОжидатьВыполненияПотоков(Задание) Экспорт
	ЗапуститьВыполнениеНовыхПотоков(Задание);
	ОжидатьВыполненияПотоков(Задание);
КонецФункции

Функция ЗапуститьВыполнениеНовыхПотоков(Задание) Экспорт
	Для Каждого Поток Из Задание.НовыеПотоки Цикл
		Наименование = Задание.Наименование + ": поток №" + Поток.НомерПотока + " из " + Задание.РасчетноеОбщееКоличествоПотоков;
		НовоеФЗ = ФоновыеЗадания.Выполнить(Задание.ИмяМетода, Поток.Параметры,, Наименование);
		Поток.ИдентификаторЗадания = НовоеФЗ.УникальныйИдентификатор;
		Поток.Состояние = СостояниеПотокаПоФоновомуЗаданию(НовоеФЗ);
		Поток.Начало = НовоеФЗ.Начало;
		Задание.ФоновыеЗадания.Добавить(НовоеФЗ);
		Для Каждого ИндексДанных Из Поток.ИндексыДанных Цикл
			Задание.ОбработкаДанных[ИндексДанных].Состояние = СостояниеОбработкиДанныхПоФоновомуЗаданию(НовоеФЗ);
		КонецЦикла;
	КонецЦикла;
КонецФункции

Функция ОжидатьВыполненияПотоков(Задание, ВсехПотоков = Ложь) Экспорт
	
	// Заполняется в процедуре "ОбновитьСвойстваПотокаПоФоновомуЗаданию".
	Задание.ИзмененныеПотоки.Очистить();
	
	Пока Задание.ФоновыеЗадания.Количество() > 0 Цикл

		ОбновленныеЗадания = ФоновыеЗадания.ОжидатьЗавершенияВыполнения(Задание.ФоновыеЗадания, Задание.Таймаут);
		
		// Получение списка активных заданий и обновление состояния потоков.
		АктивныеЗадания = Новый Массив;
		Для каждого ФоновоеЗадание Из ОбновленныеЗадания Цикл
			
			ОбновитьСвойстваПотокаПоФоновомуЗаданию(Задание, ФоновоеЗадание);
						
			Если ФоновоеЗадание.Состояние = СостояниеФоновогоЗадания.Активно Тогда
				АктивныеЗадания.Добавить(ФоновоеЗадание);
			КонецЕсли;						
			
		КонецЦикла;
		
		Задание.ФоновыеЗадания = АктивныеЗадания;
		
		Если Не ВсехПотоков Тогда
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	ОбновитьСчетчикиПотоковЗадания(Задание);
					
КонецФункции

#КонецОбласти

#Область РаботаСПотоками

Функция НовоеОписаниеПотоков()
	Таблица = Новый ТаблицаЗначений;
	// Новый, Активный, Завершен, ЗавершенАварийно, Отменен
	Таблица.Колонки.Добавить("Состояние");
	Таблица.Колонки.Добавить("НомерПотока");
	Таблица.Колонки.Добавить("ИдентификаторЗадания");
	Таблица.Колонки.Добавить("КоличествоДанных");
	Таблица.Колонки.Добавить("ИндексыДанных");
	Таблица.Колонки.Добавить("Данные");
	Таблица.Колонки.Добавить("Параметры");
	Таблица.Колонки.Добавить("АдресРезультата");
	Таблица.Колонки.Добавить("Начало");
	Таблица.Колонки.Добавить("Конец");
	Таблица.Колонки.Добавить("ИнформацияОбОшибке");
	Таблица.Колонки.Добавить("Длительность");
	Таблица.Колонки.Добавить("Результат");
	Таблица.Колонки.Добавить("СообщенияПользователю");
	Возврат Таблица;
КонецФункции

Функция НовыйПотокЗадания(Потоки, ДанныеПотока, Параметры, АдресРезультата)
	НовыйПоток = Потоки.Добавить();
	НовыйПоток.НомерПотока = Потоки.Количество();
	НовыйПоток.КоличествоДанных = ДанныеПотока.ИндексыДанных.Количество();
	НовыйПоток.ИндексыДанных = ДанныеПотока.ИндексыДанных;
	НовыйПоток.Данные = ДанныеПотока.Данные;
	НовыйПоток.Параметры = Параметры;
	НовыйПоток.АдресРезультата = АдресРезультата;
	НовыйПоток.Состояние = "Новый";
	НовыйПоток.СообщенияПользователю = Новый Массив;
	Возврат НовыйПоток;	
КонецФункции

Процедура ОбновитьСвойстваПотокаПоФоновомуЗаданию(Задание, ФоновоеЗадание)

	Поток = Задание.ВсеПотоки.Найти(ФоновоеЗадание.УникальныйИдентификатор, "ИдентификаторЗадания");
	Если Поток = Неопределено Тогда
		Возврат;
	КонецЕсли;

	// Обновление состояния обработки данных.
	Для Каждого ИндексДанных Из Поток.ИндексыДанных Цикл
		Задание.ОбработкаДанных[ИндексДанных].Состояние = СостояниеОбработкиДанныхПоФоновомуЗаданию(ФоновоеЗадание);
	КонецЦикла;
	// Обновление состояния потоков.
	НовоеСостояние = СостояниеПотокаПоФоновомуЗаданию(ФоновоеЗадание);
	Если НовоеСостояние <> Поток.Состояние Тогда
		Поток.Состояние = НовоеСостояние;
		Задание.ИзмененныеПотоки.Добавить(Поток);
	КонецЕсли;
	Если ФоновоеЗадание.Состояние = СостояниеФоновогоЗадания.ЗавершеноАварийно Тогда
		Поток.ИнформацияОбОшибке = ФоновоеЗадание.ИнформацияОбОшибке;
	КонецЕсли;
	Если ФоновоеЗадание.Состояние = СостояниеФоновогоЗадания.Завершено Тогда
		Если Не ПустаяСтрока(Поток.АдресРезультата) Тогда
			Поток.Результат = ПолучитьИзВременногоХранилища(Поток.АдресРезультата);
		КонецЕсли;
	КонецЕсли;
	Если ЗначениеЗаполнено(ФоновоеЗадание.Конец) Тогда
		Поток.Конец = ФоновоеЗадание.Конец;
		Поток.Длительность = (Поток.Конец - Поток.Начало);
	КонецЕсли;
	Поток.СообщенияПользователю = ФоновоеЗадание.ПолучитьСообщенияПользователю();
	
КонецПроцедуры

Функция СостояниеПотокаПоФоновомуЗаданию(ФоновоеЗадание) 
	Если ФоновоеЗадание.Состояние = СостояниеФоновогоЗадания.Активно Тогда
		Возврат "Активный";
	ИначеЕсли ФоновоеЗадание.Состояние = СостояниеФоновогоЗадания.Завершено Тогда
		Возврат "Завершен";
	ИначеЕсли ФоновоеЗадание.Состояние = СостояниеФоновогоЗадания.ЗавершеноАварийно Тогда
		Возврат "ЗавершенАварийно";
	ИначеЕсли ФоновоеЗадание.Состояние = СостояниеФоновогоЗадания.Отменено Тогда
		Возврат "Отменен";
	Иначе
		Возврат Строка(ФоновоеЗадание.Состояние);
	КонецЕсли;
КонецФункции

Функция СостояниеОбработкиДанныхПоФоновомуЗаданию(ФоновоеЗадание) 
	// КОбработке, Обрбатывается, Обработано, ОбработаноСОшибкой, Отменено.
	Если ФоновоеЗадание.Состояние = СостояниеФоновогоЗадания.Активно Тогда
		Возврат "Обрбатывается";
	ИначеЕсли ФоновоеЗадание.Состояние = СостояниеФоновогоЗадания.Завершено Тогда
		Возврат "Обработано";
	ИначеЕсли ФоновоеЗадание.Состояние = СостояниеФоновогоЗадания.ЗавершеноАварийно Тогда
		Возврат "ОбработаноСОшибкой";
	ИначеЕсли ФоновоеЗадание.Состояние = СостояниеФоновогоЗадания.Отменено Тогда
		Возврат "Отменено";
	Иначе
		Возврат Строка(ФоновоеЗадание.Состояние);
	КонецЕсли;
КонецФункции

Процедура ОбновитьСчетчикиПотоковЗадания(Задание)
	
	ВсеПотоки = Задание.ВсеПотоки;
	
	// Обновление групп потоков по состоянию.	
	Задание.АктивныеПотоки = ВсеПотоки.НайтиСтроки(Новый Структура("Состояние", "Активный"));
	Задание.ВыполненныеПотоки = ВсеПотоки.НайтиСтроки(Новый Структура("Состояние", "Завершен"));
	Задание.ПотокиСОшибками = ВсеПотоки.НайтиСтроки(Новый Структура("Состояние", "ЗавершенАварийно"));
	Задание.ОтмененныеПотоки = ВсеПотоки.НайтиСтроки(Новый Структура("Состояние", "Отменен"));
	
	// Обновление счетчиков потоков
	Задание.КоличествоВыполненныхПотоков = Задание.ВыполненныеПотоки.Количество();
	Задание.КоличествоПотоковСОшибками = Задание.ПотокиСОшибками.Количество();
	Задание.КоличествоОтмененныхПотоков = Задание.ОтмененныеПотоки.Количество();

КонецПроцедуры

#КонецОбласти

#Область ПорцииДанных

Функция РассчитатьПорцииДанных_ПоследовательноеНаполнение(Знач КоллекцияДанных, Знач КоличествоПорций, Знач РазмерПорции)
	
	// Равномерное размазывание данных по порциям
	// с последовательным заполнением порций.
	
	Если Не ЗначениеЗаполнено(КоличествоПорций) Тогда
		КоличествоПорций = 1;
	КонецЕсли;
	
	Результат = Новый Структура("КоличествоПорций, КоличествоДанных, Порции");
	КоличествоДанных = КоллекцияДанных.Количество();
	
	ПоказателиПорций = РассчитатьПоказателиПорций(КоличествоДанных, КоличествоПорций, РазмерПорции);
	Результат.КоличествоПорций = ПоказателиПорций.КоличествоПорций;
	Результат.КоличествоДанных = ПоказателиПорций.КоличествоДанных;
	БазовоеКоличествоВПорции = ПоказателиПорций.БазовоеКоличествоВПорции;
	РаспределитьПоПорциям = ПоказателиПорций.РаспределитьПоПорциям;
		
	Порции = Новый ТаблицаЗначений;
	Порции.Колонки.Добавить("НомерПорции");
	Порции.Колонки.Добавить("ИндексыДанных");
	Порции.Колонки.Добавить("Данные");
	
	ГлобальныйИндексДанных = 0;
	
	// Расчет порций данных (из индексов данных).
	Для ИндексПорции = 0 По Результат.КоличествоПорций - 1 Цикл
		
		НоваяСтрока = Порции.Добавить();
		НоваяСтрока.НомерПорции = ИндексПорции + 1;
		
		// Индексы данных порции.
		ИндексыДанных = Новый Массив;
		Для Счетчик = 1 По БазовоеКоличествоВПорции Цикл
			ИндексыДанных.Добавить(ГлобальныйИндексДанных);
			ГлобальныйИндексДанных = ГлобальныйИндексДанных + 1;
		КонецЦикла;
		Если РаспределитьПоПорциям > 0
			И ИндексыДанных.Количество() < РазмерПорции  Тогда
			ИндексыДанных.Добавить(ГлобальныйИндексДанных);
			ГлобальныйИндексДанных = ГлобальныйИндексДанных + 1;
			РаспределитьПоПорциям = РаспределитьПоПорциям - 1;
		КонецЕсли;
		
		// Массив данных порции.
		МассивДанных = Новый Массив;
		Для Каждого ИндексДанных Из ИндексыДанных Цикл
			МассивДанных.Добавить(КоллекцияДанных[ИндексДанных]);	
		КонецЦикла;

		НоваяСтрока.ИндексыДанных = ИндексыДанных;
		НоваяСтрока.Данные = МассивДанных;
		
	КонецЦикла;
		
	Результат.Порции = Порции;
	Возврат Результат;
	
КонецФункции

Функция РассчитатьПорцииДанных_ПараллельноеНаполнение(Знач КоллекцияДанных, Знач КоличествоПорций, Знач РазмерПорции)
	
	// Равномерное размазывание данных по порциям
	// с параллельным заполнением порций.
	
	Если Не ЗначениеЗаполнено(КоличествоПорций) Тогда
		КоличествоПорций = 1;
	КонецЕсли;
	
	Результат = Новый Структура("КоличествоПорций, КоличествоДанных, Порции");
	КоличествоДанных = КоллекцияДанных.Количество();
	
	ПоказателиПорций = РассчитатьПоказателиПорций(КоличествоДанных, КоличествоПорций, РазмерПорции);
	Результат.КоличествоПорций = ПоказателиПорций.КоличествоПорций;
	Результат.КоличествоДанных = ПоказателиПорций.КоличествоДанных;
	БазовоеКоличествоВПорции = ПоказателиПорций.БазовоеКоличествоВПорции;
	РаспределитьПоПорциям = ПоказателиПорций.РаспределитьПоПорциям;
	
	Порции = Новый ТаблицаЗначений;
	Порции.Колонки.Добавить("НомерПорции");
	Порции.Колонки.Добавить("ИндексыДанных");
	Порции.Колонки.Добавить("Данные");
	
	// Инициализация порций.
	Для НомерПорции = 1 По КоличествоПорций Цикл
		НоваяСтрока = Порции.Добавить();
		НоваяСтрока.НомерПорции = НомерПорции;
		НоваяСтрока.ИндексыДанных = Новый Массив;
		НоваяСтрока.Данные = Новый Массив;
	КонецЦикла;

	Для ИндексДанных = 0 По Результат.КоличествоДанных - 1 Цикл
		Порция = Порции[ИндексДанных % Результат.КоличествоПорций];
		Порция.ИндексыДанных.Добавить(ИндексДанных);
		Порция.Данные.Добавить(КоллекцияДанных[ИндексДанных]);
	КонецЦикла;
		
	Результат.Порции = Порции;
	Возврат Результат;
	
КонецФункции

Функция РассчитатьПорцииДанных_РазделительВОднойПорции(Знач КоллекцияДанных, Знач КоличествоПорций, Знач РазмерПорции, Знач ПолеРазделителя = "")
	
	// В разных порциях не могут быть данные с одним и тем же разделителем,
	// но в одной порции могут быть данные с разными разделителями.
	
	Если Не ЗначениеЗаполнено(КоличествоПорций) Тогда
		КоличествоПорций = 1;
	КонецЕсли;
	
	Порции = Новый ТаблицаЗначений;
	Порции.Колонки.Добавить("НомерПорции");
	Порции.Колонки.Добавить("ЗначениеРазделителя");
	Порции.Колонки.Добавить("ИндексыДанных");
	Порции.Колонки.Добавить("Данные");
	
	СвободныеПорции = Новый Соответствие;
	
	// Инициализация порций.
	Для НомерПорции = 1 По КоличествоПорций Цикл
		НоваяСтрока = Порции.Добавить();
		НоваяСтрока.НомерПорции = НомерПорции;
		НоваяСтрока.ИндексыДанных = Новый Массив;
		НоваяСтрока.Данные = Новый Массив;
		СвободныеПорции.Вставить(НомерПорции, Истина);
	КонецЦикла;
	
	// В разных порциях не может один и тот же разделитель:
	// - 1 разделитель только в 1 порции,
	// - в 1 порции может быть несколько разделителей.
	ПорцииРазделителей = Новый Соответствие; // Разделитель -> Порция.
	
	КоличествоДанныхВПорциях = 0;
	КоличествоДанных = КоллекцияДанных.Количество();
	Для ИндексДанных = 0 По КоличествоДанных - 1 Цикл
		
		Если СвободныеПорции.Количество() = 0 Тогда
			Прервать;
		КонецЕсли;

		ЭлементДанных = КоллекцияДанных[ИндексДанных];
		ЗначениеРазделителя = ЭлементДанных[ПолеРазделителя];
		                  
		// Получение номера порции по разделителю.
		НомерПорции = ПорцииРазделителей[ЗначениеРазделителя];
		Если Не ЗначениеЗаполнено(НомерПорции) Тогда
			// Подбор порции для разделителя.
			Если ПорцииРазделителей.Количество() < КоличествоПорций Тогда
				// Есть пустые порции.
				НомерПорции = ПорцииРазделителей.Количество() + 1;
			Иначе
				// Все порции заполнены, подибрается первая из свободных.
				Для Каждого КлючИЗначение Из СвободныеПорции Цикл
					НомерПорции = КлючИЗначение.Ключ;
					Прервать;
				КонецЦикла;
			КонецЕсли;
			ПорцииРазделителей.Вставить(ЗначениеРазделителя, НомерПорции);
		КонецЕсли;
		
		// Проверка, что в подобранной порции, есть свободное место.
		Если Не ЗначениеЗаполнено(СвободныеПорции[НомерПорции]) Тогда
			Продолжить;
		КонецЕсли;
		
		Порция = Порции[НомерПорции - 1];
		Порция.ИндексыДанных.Добавить(ИндексДанных);
		Порция.Данные.Добавить(ЭлементДанных);
		КоличествоДанныхВПорциях = КоличествоДанныхВПорциях + 1;
		
		// Удаление заполненной порции.
		Если Порция.Данные.Количество() >= РазмерПорции Тогда
			СвободныеПорции.Удалить(НомерПорции);
		КонецЕсли;
						
	КонецЦикла;
	
	// Удаление пустых порций.
	Для ОбратныйИндекс = 1 По КоличествоПорций Цикл
		Порция = Порции[КоличествоПорций - ОбратныйИндекс];
		Если Порция.Данные.Количество() = 0 Тогда
			Порции.Удалить(Порция);
		КонецЕсли;
	КонецЦикла;
	
	Результат = Новый Структура("КоличествоПорций, КоличествоДанных, Порции");
	Результат.КоличествоПорций = Порции.Количество();
	Результат.КоличествоДанных = КоличествоДанныхВПорциях;
	Результат.Порции = Порции;
	
	Возврат Результат;
	
КонецФункции
	
Функция РассчитатьПоказателиПорций(КоличествоДанных, КоличествоПорций, РазмерПорции)
	
	// Расчет количества обрабатываемых данных в порциях и количества заданий.
	// БазовоеКоличествоВПорции - минимальное количество данных в порции.
	// РаспределитьПоПорциям - количество для до-распределения по порциям.
	Результат = Новый Структура("КоличествоПорций, КоличествоДанных, БазовоеКоличествоВПорции, РаспределитьПоПорциям");

	Если КоличествоДанных < КоличествоПорций Тогда
		Результат.КоличествоПорций = КоличествоДанных;
		Результат.КоличествоДанных = КоличествоДанных;
		Результат.БазовоеКоличествоВПорции = 1;
		Результат.РаспределитьПоПорциям = 0;
	ИначеЕсли КоличествоДанных < КоличествоПорций * РазмерПорции Тогда
		Результат.КоличествоПорций = КоличествоПорций;
		Результат.КоличествоДанных = КоличествоДанных;
		Результат.БазовоеКоличествоВПорции = Цел(КоличествоДанных / КоличествоПорций);
		Результат.РаспределитьПоПорциям = КоличествоДанных % КоличествоПорций;
	Иначе
		Результат.КоличествоПорций = КоличествоПорций;
		Результат.КоличествоДанных = КоличествоПорций * РазмерПорции;
		Результат.БазовоеКоличествоВПорции = РазмерПорции;
		Результат.РаспределитьПоПорциям = КоличествоДанных % КоличествоПорций;
	КонецЕсли;
	
	Возврат Результат;

КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыФункции

Процедура ВыполнитьКод_Служебная(ТекстКода, КоллекцияДанных, ДополнительныеПараметры, АдресРезультата) Экспорт
	
	Результат = Неопределено;
	
	Выполнить(ТекстКода);
	
	ПоместитьВоВременноеХранилище(Результат, АдресРезультата);
	
КонецПроцедуры

#КонецОбласти
