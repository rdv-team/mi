
#Область ПрограммныйИнтерфейс

// Процедура - Добавить реквизит колонки к результату запроса
//
// Параметры:
//  Результат			 - ТаблицаЗначений	 - 
//  КолонкаРезультата	 - Строка			 - Колонка из которой будет получено значение
//  ИмяРеквизита		 - Строка			 - Имя рекизита, который нужно получить и заполнить
//
Процедура ДобавитьРеквизитКолонкиКРезультатуЗапроса(Результат, КолонкаРезультата, ИмяРеквизита) Экспорт
	
	КэшПоТипам = Новый Соответствие;
	
	Для каждого СтрокаТаблицы из Результат Цикл
		Если НЕ ЗначениеЗаполнено(СтрокаТаблицы[КолонкаРезультата]) Тогда
			Продолжить;
		КонецЕсли;
		
		ТипТекущегоДокумента = ТипЗнч(СтрокаТаблицы[КолонкаРезультата]);
		МассивТипа = КэшПоТипам[ТипТекущегоДокумента];
		Если МассивТипа = Неопределено Тогда
			МассивТипа = Новый Массив;
			КэшПоТипам.Вставить(ТипТекущегоДокумента, МассивТипа);
		КонецЕсли;
		МассивТипа.Добавить(СтрокаТаблицы[КолонкаРезультата]);
	КонецЦикла;
	
	Если КэшПоТипам.Количество()=0 Тогда
		Возврат;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	
	МассивЧастейЗапроса = Новый Массив;
	ШаблонЗапроса =
	"ВЫБРАТЬ
	|	Объект.Ссылка КАК Ссылка,
	|	Объект.%2     КАК %2
	|ИЗ
	|	%1 КАК Объект
	|ГДЕ
	|	Объект.Ссылка В(&%3)";
	
	Для Каждого КлючИЗначение Из КэшПоТипам Цикл
		
		МетаданныеТипа = Метаданные.НайтиПоТипу(КлючИЗначение.Ключ);
		Если МетаданныеТипа = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если МетаданныеТипа.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
			// Для одного реквизита пропустим запрос, для нескольких заменим на NULL
			Продолжить;
		КонецЕсли;
		
		ПолноеИмяМетаданных = МетаданныеТипа.ПолноеИмя();
		ИмяПараметра        = "ОбъектыТипа_" + СтрЗаменить(ПолноеИмяМетаданных, ".", "_");
			
		ЗапросТипа = СтрШаблон(ШаблонЗапроса, ПолноеИмяМетаданных, ИмяРеквизита, ИмяПараметра);
		МассивЧастейЗапроса.Добавить(ЗапросТипа);
		
		Запрос.УстановитьПараметр(ИмяПараметра, КлючИЗначение.Значение);
		
	КонецЦикла;
	
	Если МассивЧастейЗапроса.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	РазделительОбъединитьВсе =
	"
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|";
	Запрос.Текст = СтрСоединить(МассивЧастейЗапроса, РазделительОбъединитьВсе);
	
	Результат.Индексы.Добавить(КолонкаРезультата);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		ПараметрыОтбора = Новый Структура;
		ПараметрыОтбора.Вставить(КолонкаРезультата, Выборка.Ссылка);
		
		НайденныеСтроки = Результат.НайтиСтроки(ПараметрыОтбора);
		Для Каждого Строка Из НайденныеСтроки Цикл
			Строка[ИмяРеквизита] = Выборка[ИмяРеквизита];
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

// Функция - Значения реквизитов объектов запрос для объектов нескольких типов
//
// Параметры:
//  Объекты				 - Массив	 - Список объектов
//  Реквизиты			 - Массив	 - Список структур с именами и значениями по умолчанию "Имя, ЗначениеПоУмолчанию"
//  ТаблицаДляПомещения	 - Строка	 - Имя таблицы для помещения результата
// 
// Возвращаемое значение:
//  Запрос - Запрос для получения значений реквизитов
//
Функция ЗначенияРеквизитовОбъектов_ЗапросДляОбъектовНесколькихТипов(Объекты, Реквизиты, ТаблицаДляПомещения = "") Экспорт
	
	Запрос = Новый Запрос;
	
	Если Реквизиты.Количество() = 0 Тогда
		Возврат Запрос;
	КонецЕсли;
		
	КэшПоТипам = Новый Соответствие;
	
	Для Каждого Объект Из Объекты Цикл
		Если НЕ ЗначениеЗаполнено(Объект) Тогда
			Продолжить;
		КонецЕсли;
		
		ТипТекущегоОбъекта = ТипЗнч(Объект);
		МассивТипа = КэшПоТипам[ТипТекущегоОбъекта];
		Если МассивТипа = Неопределено Тогда
			МассивТипа = Новый Массив;
			КэшПоТипам.Вставить(ТипТекущегоОбъекта, МассивТипа);
		КонецЕсли;
		МассивТипа.Добавить(Объект);
	КонецЦикла;
	
	Если КэшПоТипам.Количество()=0 Тогда
		Возврат Запрос;
	КонецЕсли;
	
	МассивЧастейЗапроса = Новый Массив;
	ШаблонЗапросаПоместить =
	"ВЫБРАТЬ
	|	Объект.Ссылка КАК Ссылка,
	|	%2
	|ПОМЕСТИТЬ %4
	|ИЗ
	|	%1 КАК Объект
	|ГДЕ
	|	Объект.Ссылка В(&%3)";
	ШаблонЗапроса =
	"ВЫБРАТЬ
	|	Объект.Ссылка КАК Ссылка,
	|	%2
	|ИЗ
	|	%1 КАК Объект
	|ГДЕ
	|	Объект.Ссылка В(&%3)";
	
	ИспользоватьШаблонПоместить = ЗначениеЗаполнено(ТаблицаДляПомещения);
	Для Каждого КлючИЗначение Из КэшПоТипам Цикл
		
		МетаданныеТипа = Метаданные.НайтиПоТипу(КлючИЗначение.Ключ);
		Если МетаданныеТипа = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ПолноеИмяМетаданных = МетаданныеТипа.ПолноеИмя();
		ИмяПараметра        = СтрШаблон("ОбъектыТипа_%1",
		                                СтрЗаменить(ПолноеИмяМетаданных, ".", "_"));
		
		МассивВыраженийРеквизитов = Новый Массив;
		
		Для Каждого Реквизит Из Реквизиты Цикл
			ИмяРеквизита = Реквизит.Имя;
			
			ЭтоСтандартныйРеквизит = Реквизит.Свойство("ЭтоСтандартныйРеквизит")
			                         И Реквизит.ЭтоСтандартныйРеквизит = Истина;
			
			Если Не ЭтоСтандартныйРеквизит
			   И МетаданныеТипа.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
				ИмяПараметраЗначениеПоУмолчанию =
				    СтрШаблон("ЗначениеПоУмолчанию_Тип_%1_Реквизит_%2",
					          СтрЗаменить(ПолноеИмяМетаданных, ".", "_"),
					          ИмяРеквизита);
				
				ВыражениеРеквизита = СтрШаблон("&%2 КАК %1",
				                               ИмяРеквизита,
				                               ИмяПараметраЗначениеПоУмолчанию);
				Запрос.УстановитьПараметр(ИмяПараметраЗначениеПоУмолчанию, Реквизит.ЗначениеПоУмолчанию);
			Иначе
				ВыражениеРеквизита = СтрШаблон("%1 КАК %1", ИмяРеквизита);
			КонецЕсли;
			
			МассивВыраженийРеквизитов.Добавить(ВыражениеРеквизита);
		КонецЦикла;
		
		РазделительРеквизитов = ",
		|	";
		ВыражениеРеквизитов = СтрСоединить(МассивВыраженийРеквизитов, РазделительРеквизитов);
		
		Если ИспользоватьШаблонПоместить Тогда
			ЗапросТипа = СтрШаблон(ШаблонЗапросаПоместить,
			                           ПолноеИмяМетаданных,
			                           ВыражениеРеквизитов,
			                           ИмяПараметра,
			                           ТаблицаДляПомещения);
			ИспользоватьШаблонПоместить = Ложь;
		Иначе
			ЗапросТипа = СтрШаблон(ШаблонЗапроса,
			                           ПолноеИмяМетаданных,
			                           ВыражениеРеквизитов,
			                           ИмяПараметра);
		КонецЕсли;
		МассивЧастейЗапроса.Добавить(ЗапросТипа);
		
		Запрос.УстановитьПараметр(ИмяПараметра, КлючИЗначение.Значение);
		
	КонецЦикла;
	
	Если МассивЧастейЗапроса.Количество() = 0 Тогда
		Возврат Запрос;
	КонецЕсли;
	
	РазделительОбъединитьВсе =
	"
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|";
	Запрос.Текст = СтрСоединить(МассивЧастейЗапроса, РазделительОбъединитьВсе);
	
	Возврат Запрос;
	
КонецФункции

// Переводит время из заданных единиц времени в секунды
//
// Параметры:
//  Время					 - Число		 - время в указанных единицах измерения времени
//  ЕдиницаИзмеренияВремени	 - Строка		 - наименование единицы измерения времени.
// 
// Возвращаемое значение:
//   - Число - время в секундах
//
// RM-2481 14.06.2022 tosina@rdv-it.ru	
//
Функция ВремяВСекундах(Время, ЕдиницаВремени) Экспорт
	
	Если Время = 0 Тогда
		Возврат 0;
	КонецЕсли;
	
	Если ЕдиницаВремени = "День" Тогда
		ВремяВСекундах = Время * 86400; // 60 * 60 * 24
	ИначеЕсли ЕдиницаВремени = "Минута" Тогда
		ВремяВСекундах = Время * 60;
	ИначеЕсли ЕдиницаВремени = "Час" Тогда
		ВремяВСекундах = Время * 3600; //60 * 60;
	ИначеЕсли ЕдиницаВремени = "Секунда" Тогда
		ВремяВСекундах = Время;
	Иначе
		ТекстОшибки = НСтр("ru = 'Неправильное значение параметра ""ЕдиницаВремени"",
                            |допустимые значения: День, Час, Минута, Секунда.'");
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;

	Возврат ВремяВСекундах;
	
КонецФункции

// Генерирует имя объекта по его представлению в формате CamelCase.
// Пример, для строки "Наименование объекта" результатом будет "НаименованиеОбъекта". 
//
// Параметры:
//  Синоним	 - Строка - представление объекта.
// 
// Возвращаемое значение:
//   - Строка - имя объекта по его представлению.
//
Функция ИмяИзСинонима(Знач Синоним) Экспорт

	Если Не ЗначениеЗаполнено(Синоним) Тогда
		Возврат "";
	КонецЕсли;
	
	ПрефиксИмени = "";
	
	// Формирование префикса не используемого объекта.
	ПрефиксСинонима = НСтр("ru = '(Не используется)'");
	Если СтрНайти(НРег(Синоним), НРег(ПрефиксСинонима)) > 0 Тогда
		Синоним = СтрЗаменить(Синоним, ПрефиксСинонима, "");
		ПрефиксИмени = НСтр("ru = 'Удалить'");
	КонецЕсли;	
	
	// Допустимые символы.
	Цифры = "0123456789";
	Буквы = "ABCDEFGHIJKLMNOPQRSTUVWXYZАБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ";
	Массив = Новый Массив;
	Массив.Добавить(НРег(Буквы));
	Массив.Добавить(Буквы);
	Массив.Добавить(Цифры);
	ДопустимыеСимволы = СтрСоединить(Массив);
	
	// Недопустимый символ в конец, чтобы точно прочитать последнее слово.
	Синоним = Синоним + "$";

	// Массив слов синонима.
	Слова = Новый Массив;
	ТекущееСлово = Новый Массив;	
	ДлинаСинонима = СтрДлина(Синоним);
	Для НомерСимвола = 1 По ДлинаСинонима Цикл
		Символ = Сред(Синоним, НомерСимвола, 1);
		Если Найти(ДопустимыеСимволы, Символ) > 0 Тогда
			ТекущееСлово.Добавить(Символ);
		Иначе
			Если ТекущееСлово.Количество() > 0 Тогда
				ТекущееСлово[0] = ВРег(ТекущееСлово[0]);
				Слова.Добавить(СтрСоединить(ТекущееСлово, ""));
				ТекущееСлово.Очистить();
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	// Добавление префикса имени ("Удалить").
	Если ПрефиксИмени <> "" Тогда
		Слова.Вставить(0, ПрефиксИмени);
	КонецЕсли;
	
	Возврат СтрСоединить(Слова);

КонецФункции

Функция ЭтоФайловаяИБ(Знач СтрокаСоединенияИБ = "") Экспорт
	
	Если ПустаяСтрока(СтрокаСоединенияИБ) Тогда
		СтрокаСоединенияИБ =  СтрокаСоединенияИнформационнойБазы();
	КонецЕсли;
	
	Возврат СтрНайти(ВРег(СтрокаСоединенияИБ), "FILE=") = 1;
	
КонецФункции 

// Возвращает не выведенные сообщения пользователю в виде единого текста.
//
// Параметры:
//  Разделитель			 - Строка - Строка, которая будет вставлена между сообщениями пользователю.
//									По умолчанию: перенос строки.
//  УдалятьПолученные	 - Булево - Признак необходимости удаления полученных сообщений из списка.
// 
// Возвращаемое значение:
//   - Строка - сообщения пользователю.
//
Функция ТекстСообщенийПользователю(Знач Разделитель = Неопределено, Знач УдалятьПолученные = Ложь) Экспорт
	
	// VELO-619 01.09.2023 pnesmelov@rdv-it.ru 
	
	МассивТекстов = Новый Массив;
	
	Для каждого Сообщение Из ПолучитьСообщенияПользователю(УдалятьПолученные) Цикл
		
		МассивТекстов.Добавить(Сообщение.Текст);
		
	КонецЦикла;
	
	Если Разделитель = Неопределено Тогда
		Разделитель = Символы.ПС;
	КонецЕсли;
	
	ТекстСообщений = СтрСоединить(МассивТекстов, Разделитель);
	
	Возврат ТекстСообщений;
		
КонецФункции

Функция ИспользуетсяПериодичностьРегистра(МетаданныеРегистра, Периодичность)
	
	// VELO-625 19.09.2023 afil@rdv-it.ru
	
	ОжидаемоеЗначение = Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений[Периодичность];
	
	Возврат МетаданныеРегистра.ПериодичностьРегистраСведений = ОжидаемоеЗначение;
	
КонецФункции

// Возвращает значения полей записи регистра, используя ключ записи.
//
// Параметры:
//  КлючЗаписи	 - РегистрСведенийКлючЗаписи
//  			 - РегистрНакопленияКлючЗаписи
//  			 - РегистрБухгалтерииКлючЗаписи
//  			 - РегистрРасчетаКлючЗаписи - идентификатор записи регистра.
// 
// Возвращаемое значение:
//   - Структура - содержит имена (ключи) и значения всех полей затребованной записи регистра.
//
Функция ЗначенияЗаписиРегистра(КлючЗаписи) Экспорт
	
	// VELO-625 19.09.2023 afil@rdv-it.ru
	
	МетаданныеРегистра = КлючЗаписи.Метаданные();
	
	Отбор = Новый Массив;
	
	Если Метаданные.РегистрыСведений.Содержит(МетаданныеРегистра) Тогда		
		
		Если ИспользуетсяПериодичностьРегистра(МетаданныеРегистра, "ПозицияРегистратора") Тогда
			Отбор.Добавить("Период");
			Отбор.Добавить("Регистратор");
		ИначеЕсли Не ИспользуетсяПериодичностьРегистра(МетаданныеРегистра, "Непериодический") Тогда
			Отбор.Добавить("Период");
		КонецЕсли;
		
		Для Каждого Измерение Из МетаданныеРегистра.Измерения Цикл
			Отбор.Добавить(Измерение.Имя);
		КонецЦикла;		
		
	Иначе
		
		Отбор.Добавить("Период");
		Отбор.Добавить("Регистратор");
		
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = СтрШаблон("ВЫБРАТЬ Т.* ИЗ %1 КАК Т ГДЕ ИСТИНА", МетаданныеРегистра.ПолноеИмя());
	
	Для Каждого ИмяПоля Из Отбор Цикл
		
		Запрос.Текст = Запрос.Текст + СтрШаблон(" И Т.%1 = &%1", ИмяПоля);
		Запрос.УстановитьПараметр(ИмяПоля, КлючЗаписи[ИмяПоля]);
		
	КонецЦикла;
	
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Результат = СтрокаТаблицыЗначенийВСтруктуру(Выборка);
	
	Возврат Результат;
	
КонецФункции

// Преобразует строку таблицы значений в структуру.
// Свойства структуры и их значения совпадают с колонками переданной строки.
//
// Параметры:
//  СтрокаТаблицыЗначений - СтрокаТаблицыЗначений - строка таблицы значений.
//
// Возвращаемое значение:
//  Структура - преобразованная строка таблицы значений.
//
Функция СтрокаТаблицыЗначенийВСтруктуру(СтрокаТаблицыЗначений, ИспользоватьФиксированнуюСтруктуру = Ложь) Экспорт
	
	// VELO-625 19.09.2023 afil@rdv-it.ru
	
	Структура = Новый Структура;
	Для Каждого Колонка Из СтрокаТаблицыЗначений.Владелец().Колонки Цикл
		Структура.Вставить(Колонка.Имя, СтрокаТаблицыЗначений[Колонка.Имя]);
	КонецЦикла;
	
	Если ИспользоватьФиксированнуюСтруктуру Тогда
		Возврат Новый ФиксированнаяСтруктура(Структура);
	Иначе
		Возврат Структура;
	КонецЕсли;
	
КонецФункции

Функция УстановленПризнакВСтруктуре(Структура, ИмяСвойства)
	
	// VELO-614 22.09.2023 astepanov@rdv-it.ru
	// Признак  - свойство с типом булево, проверяем не установлено ли оно в значение Истина
	
	ЗначениеСвойства = Неопределено;
	Структура.Свойство(ИмяСвойства, ЗначениеСвойства);
	Результат = (ЗначениеСвойства = Истина);
	
	Возврат Результат;
	
КонецФункции

Процедура ДобавитьСтрокиВТаблицуЗначений(Приемник, Источник) Экспорт
	
	// VELO-611 30.09.2023 astepanov@rdv-it.ru
	
	Для Каждого Строка Из Источник Цикл
		НоваяСтрока = Приемник.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
	КонецЦикла;
	
КонецПроцедуры

Функция ОстаткиРегистраНакопленияСРегистраторами(ИмяРегистра, ТаблицаОтбора) Экспорт
	
	// VELO-732 30.10.2023 pkharchuk@rdv-it.ru
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ТаблицаОтбораОстатков.Измерение КАК Измерение
	|ПОМЕСТИТЬ вт_ТаблицаОтбораОстатков
	|ИЗ
	|	&ТаблицаОтбораОстатков КАК ТаблицаОтбораОстатков
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТаблицаОстатки.Измерение КАК Измерение,
	|	ТаблицаОстатки.РесурсОстаток КАК Ресурс
	|ИЗ
	|	РегистрНакопления.ТоварыНаСкладах.Остатки(&ТекущаяДата,
	|	                                          (&ИзмеренияДляОтбораОстатков) В (ВЫБРАТЬ
	|	                                                                               ТаблицаОтбораОстатков.Измерение КАК Измерение
	|	                                                                           ИЗ
	|	                                                                               вт_ТаблицаОтбораОстатков КАК ТаблицаОтбораОстатков)) КАК ТаблицаОстатки
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТаблицаОбороты.Период КАК Период,
	|	ТаблицаОбороты.Регистратор КАК Регистратор,
	|	ТаблицаОбороты.Измерение КАК Измерение,
	|	ТаблицаОбороты.РесурсОборот КАК Ресурс
	|ИЗ
	|	РегистрНакопления.ТоварыНаСкладах.Обороты(,
	|	                                          &ТекущаяДата,
	|	                                          Регистратор,
	|	                                          (&ИзмеренияДляОтбораОстатков) В (ВЫБРАТЬ
	|	                                                                               ТаблицаОтбораОстатков.Измерение КАК Измерение
	|	                                                                           ИЗ
	|	                                                                               вт_ТаблицаОтбораОстатков КАК ТаблицаОтбораОстатков)) КАК ТаблицаОбороты
	|
	|УПОРЯДОЧИТЬ ПО
	|	ТаблицаОбороты.Период УБЫВ";
	Запрос.УстановитьПараметр("ТаблицаОтбораОстатков", ТаблицаОтбора);
	
	// ToDo: Ищем обороты приходов для заполнения строк остатков
	ТекстЗапросаДляОборотов =
	"ВЫБРАТЬ
	|	ТаблицаОтбораОборотов.Измерение КАК Измерение
	|ПОМЕСТИТЬ вт_ТаблицаОтбораОборотов
	|ИЗ
	|	&ТаблицаОтбораОборотов КАК ТаблицаОтбораОборотов
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТаблицаОбороты.Регистратор КАК Регистратор,
	|	ТаблицаОбороты.Измерение КАК Измерение,
	|	ТаблицаОбороты.РесурсОстаток КАК РесурсОстаток
	|ИЗ
	|	РегистрНакопления.ТоварыНаСкладах.Обороты(&НачалоПериода,
	|	                                          &КонецПериода,
	|	                                          Регистратор,
	|	                                          (&ИзмеренияДляОтбораОборотов) В (ВЫБРАТЬ
	|	                                                                               ТаблицаОтбораОборотов.Измерение КАК Измерение
	|	                                                                           ИЗ
	|	                                                                               вт_ТаблицаОтбораОборотов КАК ТаблицаОтбораОборотов)) КАК ТаблицаОбороты
	|
	|УПОРЯДОЧИТЬ ПО
	|	ТаблицаОбороты.Период УБЫВ";
	
	ПереносСтроки = "
					|";
	
	Массив_ПоляДляТаблицыОтбораОстатков             = Новый Массив;
	
	Массив_ПоляИзмеренияДляТаблицыОстатков          = Новый Массив;
	Массив_ПоляРесурсыДляТаблицыОстатков            = Новый Массив;
	Массив_ПоляДляУсловияВиртуальнойТаблицыОстатков = Новый Массив;
	
	Массив_ПоляДляТаблицыОтбораОборотов             = Новый Массив;
	Массив_ПоляДляУсловияВиртуальнойТаблицыОборотов = Новый Массив;
	
	Массив_ПоляИзмеренияДляТаблицыОборотов          = Новый Массив;
	Массив_ПоляРесурсыДляТаблицыОборотов            = Новый Массив;
	
	Для Каждого КолонкаОтбора Из ТаблицаОтбора.Колонки Цикл
		Массив_ПоляДляТаблицыОтбораОстатков.Добавить(СтрШаблон("ТаблицаОтбораОстатков.%1 КАК %1", КолонкаОтбора.Имя));
		
		Массив_ПоляДляУсловияВиртуальнойТаблицыОстатков.Добавить(КолонкаОтбора.Имя);
	КонецЦикла;
	
	МетаданныеРегистра = Метаданные.НайтиПоПолномуИмени("РегистрНакопления." + ИмяРегистра);
	Для Каждого МетаданныеИзмерения Из МетаданныеРегистра.Измерения Цикл
		Массив_ПоляИзмеренияДляТаблицыОстатков.Добавить(СтрШаблон("ТаблицаОстатки.%1 КАК %1", МетаданныеИзмерения.Имя));
		
		Массив_ПоляДляТаблицыОтбораОборотов.Добавить(СтрШаблон("ТаблицаОтбораОборотов.%1 КАК %1", МетаданныеИзмерения.Имя));
		
		Массив_ПоляИзмеренияДляТаблицыОборотов.Добавить(СтрШаблон("ТаблицаОбороты.%1 КАК %1", МетаданныеИзмерения.Имя));
		
		Массив_ПоляДляУсловияВиртуальнойТаблицыОборотов.Добавить(МетаданныеИзмерения.Имя);
	КонецЦикла;
	Для Каждого МетаданныеРесурса Из МетаданныеРегистра.Ресурсы Цикл
		Массив_ПоляРесурсыДляТаблицыОстатков.Добавить(СтрШаблон("ТаблицаОстатки.%1Остаток КАК %1", МетаданныеРесурса.Имя));
		
		Массив_ПоляРесурсыДляТаблицыОборотов.Добавить(СтрШаблон("ТаблицаОбороты.%1Приход КАК %1Приход", МетаданныеРесурса.Имя));
		Массив_ПоляРесурсыДляТаблицыОборотов.Добавить(СтрШаблон("ТаблицаОбороты.%1Расход КАК %1Расход", МетаданныеРесурса.Имя));
	КонецЦикла;
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ТаблицаОтбораОстатков.Измерение КАК Измерение",
	                                         СтрСоединить(Массив_ПоляДляТаблицыОтбораОстатков, "," + ПереносСтроки + "	"));
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ТаблицаОстатки.Измерение КАК Измерение",
	                                         СтрСоединить(Массив_ПоляИзмеренияДляТаблицыОстатков, "," + ПереносСтроки + "	"));
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ТаблицаОстатки.РесурсОстаток КАК Ресурс",
	                                         СтрСоединить(Массив_ПоляРесурсыДляТаблицыОстатков, "," + ПереносСтроки + "	"));
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ТаблицаОбороты.Измерение КАК Измерение",
	                                         СтрСоединить(Массив_ПоляИзмеренияДляТаблицыОборотов, "," + ПереносСтроки + "	"));
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ТаблицаОбороты.РесурсОборот КАК Ресурс",
	                                         СтрСоединить(Массив_ПоляРесурсыДляТаблицыОборотов, "," + ПереносСтроки + "	"));
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ИзмеренияДляОтбораОстатков",
	                                         СтрСоединить(Массив_ПоляДляУсловияВиртуальнойТаблицыОстатков, ", "));
	
	ТекстЗапросаДляОборотов = СтрЗаменить(Запрос.Текст, "ТаблицаОтбораОборотов.Измерение КАК Измерение",
	                                                    СтрСоединить(Массив_ПоляДляТаблицыОтбораОборотов, ", " + ПереносСтроки + "	"));
	ТекстЗапросаДляОборотов = СтрЗаменить(Запрос.Текст, "ТаблицаОбороты.Измерение КАК Измерение",
	                                                    СтрСоединить(Массив_ПоляИзмеренияДляТаблицыОборотов, ", " + ПереносСтроки + "	"));
	ТекстЗапросаДляОборотов = СтрЗаменить(Запрос.Текст, "ТаблицаОстатки.Ресурс КАК Ресурс",
	                                                    СтрСоединить(Массив_ПоляРесурсыДляТаблицыОборотов, "," + ПереносСтроки + "	"));
	ТекстЗапросаДляОборотов = СтрЗаменить(Запрос.Текст, "&ИзмеренияДляОтбораОборотов",
	                                                    СтрСоединить(Массив_ПоляДляУсловияВиртуальнойТаблицыОборотов, ", "));
											 
	ТекущаяДата = ТекущаяДатаСеанса();
	Запрос.УстановитьПараметр("ТекущаяДата",   ТекущаяДата);
	Запрос.УстановитьПараметр("ТаблицаОтбора", ТаблицаОтбора);
	
	МассивРезультатов = Запрос.ВыполнитьПакет();
	ТаблицаТекущиеОстатки = МассивРезультатов[1].Выгрузить();
	ТаблицаТекущиеОбороты = МассивРезультатов[2].Выгрузить();
	
	// Начнем распределение
	
	//++ VELO-1524 26.01.2024 pkharchuk@rdv.team
	//ТаблицаРезультат = ТаблицаТекущиеОстатки.СкопироватьКолонки();
	ТаблицаРезультат = Новый ТаблицаЗначений;
	Для Каждого ОписаниеКолонки Из ТаблицаТекущиеОстатки.Колонки Цикл
		Если ОписаниеКолонки.ТипЗначения.СодержитТип(Тип("Null")) Тогда
			ОписаниеТиповКолонки = Новый ОписаниеТипов(ОписаниеКолонки.ТипЗначения, , "Null");
		Иначе
			ОписаниеТиповКолонки = ОписаниеКолонки.ТипЗначения;
		КонецЕсли;
		
		ТаблицаРезультат.Колонки.Добавить(ОписаниеКолонки.Имя,
		                                  ОписаниеТиповКолонки,
		                                  ОписаниеКолонки.Заголовок,
		                                  ОписаниеКолонки.Ширина);
	КонецЦикла;
	//-- VELO-1524 26.01.2024 pkharchuk@rdv.team
	ТаблицаРезультат.Колонки.Добавить("Регистратор", ТаблицаТекущиеОбороты.Колонки.Регистратор.ТипЗначения);
	ТаблицаРезультат.Колонки.Добавить("Период",      ТаблицаТекущиеОбороты.Колонки.Период.ТипЗначения);
	
	МассивИменИзмерений = Новый Массив;
	Для Каждого МетаданныеИзмерения Из МетаданныеРегистра.Измерения Цикл
		МассивИменИзмерений.Добавить(МетаданныеИзмерения.Имя);
	КонецЦикла;
	КлючиСтруктурыПоиска = СтрСоединить(МассивИменИзмерений, ", ");
	
	Для Каждого СтрокаОстатков Из ТаблицаТекущиеОстатки Цикл
		СтруктураПоиска = Новый Структура(КлючиСтруктурыПоиска);
		ЗаполнитьЗначенияСвойств(СтруктураПоиска, СтрокаОстатков);
		
		МассивСтрокОборотов = ТаблицаТекущиеОбороты.НайтиСтроки(СтруктураПоиска);
		Для Каждого СтрокаОборота Из МассивСтрокОборотов Цикл
			ЕстьНераспределенныеОстатки = Ложь;
			
			НоваяСтрокаРезультата = Неопределено;
			
			Для Каждого МетаданныеРесурса Из МетаданныеРегистра.Ресурсы Цикл
				Если СтрокаОстатков[МетаданныеРесурса.Имя] = 0 Тогда
					Продолжить;
				КонецЕсли;
				
				ТекущийОстаток       = СтрокаОстатков[МетаданныеРесурса.Имя];
				ОстатокПоложительный = ТекущийОстаток > 0;
				
				Если ТекущийОстаток = 0 Тогда
					Прервать;
				КонецЕсли;
				
				ТекущийОборот = СтрокаОборота[МетаданныеРесурса.Имя + ?(ОстатокПоложительный, "Приход", "Расход")];
				Если ТекущийОборот = 0 Тогда
					//++ VELO-1780 25.03.2024 lbannykh@rdv.team 
					Если ТекущийОстаток <> 0 Тогда
						ЕстьНераспределенныеОстатки = Истина;
					КонецЕсли;
					//-- VELO-1780 25.03.2024 lbannykh@rdv.team
					Продолжить;
				КонецЕсли;
				
				Если ОстатокПоложительный Тогда
					ЧастичныйОборот = Мин(ТекущийОстаток, ТекущийОборот);
					
					ТекущийОстаток = ТекущийОстаток - ЧастичныйОборот;
				Иначе
					ЧастичныйОборот = Макс(ТекущийОстаток, ТекущийОборот);
					
					ТекущийОстаток = ТекущийОстаток - ЧастичныйОборот;
				КонецЕсли;
				
				Если НоваяСтрокаРезультата = Неопределено Тогда
					НоваяСтрокаРезультата = ТаблицаРезультат.Добавить();
					
					ЗаполнитьЗначенияСвойств(НоваяСтрокаРезультата, СтрокаОборота, КлючиСтруктурыПоиска);
					НоваяСтрокаРезультата.Регистратор = СтрокаОборота.Регистратор;
					НоваяСтрокаРезультата.Период      = СтрокаОборота.Период;
				КонецЕсли;
				
				НоваяСтрокаРезультата[МетаданныеРесурса.Имя] = ЧастичныйОборот;
				
				Если ТекущийОстаток <> 0 Тогда
					ЕстьНераспределенныеОстатки = Истина;
				КонецЕсли;
			КонецЦикла;
			
			Если Не ЕстьНераспределенныеОстатки Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат ТаблицаРезультат;
	
КонецФункции

Функция ТаблицаСОграничениемПоБазе(ТаблицаИсточник, ТаблицаБаза, ПолеОграничения, ПоляСвёртки, ПоляДляПропорциональногоУменьшения) Экспорт
	
	// VELO-704 03.11.2023 pkharchuk@rdv-it.ru
	
	#Если Типизация Тогда
		ТаблицаИсточник = Новый ТаблицаЗначений;
		ТаблицаБаза     = Новый ТаблицаЗначений;
	#КонецЕсли
	
	ПоляСвёрткиСтрокой      = ПоляСвёртки;
	ПоляСуммированияСтрокой = ПолеОграничения + ?(ЗначениеЗаполнено(ПоляДляПропорциональногоУменьшения), ", ", "") + ПоляДляПропорциональногоУменьшения;
	
	ПоляДляПропорциональногоУменьшенияМассив = СтрРазделить(ПоляДляПропорциональногоУменьшения, ", ", Ложь);
	
	ТаблицаБазаТекущая = ТаблицаБаза.Скопировать();
	ТаблицаБазаТекущая.Свернуть(ПоляСвёртки, ПолеОграничения);
	
	ТаблицаРезультат = ТаблицаИсточник.СкопироватьКолонки();
	
	Для Каждого СтрокаБазы Из ТаблицаБазаТекущая Цикл
		Если СтрокаБазы[ПолеОграничения] = 0 Тогда
			// Пересчет не требуется
			Продолжить;
		КонецЕсли;
		
		СтруктураПоиска = Новый Структура(ПоляСвёртки);
		ЗаполнитьЗначенияСвойств(СтруктураПоиска, СтрокаБазы);
		
		СтрокиИсточника = ТаблицаИсточник.НайтиСтроки(СтруктураПоиска);
		
		Для Каждого СтрокаИсточника Из СтрокиИсточника Цикл
			Если СтрокаИсточника[ПолеОграничения] = 0 Тогда
				// Пересчет не требуется
				Продолжить;
			КонецЕсли;
			
			СтрокаРезультата = ТаблицаРезультат.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаРезультата, СтрокаИсточника);
			
			КолВоИсходное = СтрокаИсточника[ПолеОграничения];
			КолВоЦелевое  = Мин(СтрокаБазы[ПолеОграничения], СтрокаИсточника[ПолеОграничения]);
			
			СтрокаРезультата[ПолеОграничения] = КолВоЦелевое;
			Для Каждого ПолеДляПропроциональногоРасчета Из ПоляДляПропорциональногоУменьшенияМассив Цикл
				Если КолВоИсходное = КолВоЦелевое Тогда
					// Пересчет не требуется
				Иначе
					ЗначениеПослеРасчета = СтрокаИсточника[ПолеДляПропроциональногоРасчета] * КолВоЦелевое / КолВоИсходное;
					СтрокаРезультата[ПолеДляПропроциональногоРасчета] = ЗначениеПослеРасчета;
				КонецЕсли;
				
				СтрокаИсточника[ПолеДляПропроциональногоРасчета]  = СтрокаИсточника[ПолеДляПропроциональногоРасчета]
				                                                    - СтрокаРезультата[ПолеДляПропроциональногоРасчета];
			КонецЦикла;
			
			СтрокаБазы[ПолеОграничения]      = СтрокаБазы[ПолеОграничения]      - КолВоЦелевое;
			СтрокаИсточника[ПолеОграничения] = СтрокаИсточника[ПолеОграничения] - КолВоЦелевое;
		КонецЦикла;
	КонецЦикла;
	
	Возврат ТаблицаРезультат;
	
КонецФункции

Процедура ЗаполнитьКолонкиТаблицыПоБазе(ТаблицаПриемник, ТаблицаБаза, ПоляКлюча, ПоляЗаполнения, ПолеОграничения, ПоляДляПропорциональногоУменьшения) Экспорт
	
	// VELO-1622 29.02.2024 pkharchuk@rdv.team
	
	#Если Типизация Тогда
		ТаблицаПриемник = Новый ТаблицаЗначений;
		ТаблицаБаза     = Новый ТаблицаЗначений;
	#КонецЕсли
	
	ПоляКлючаСтрокой        = ПоляКлюча;
	ПоляЗаполненияСтрокой   = ПоляЗаполнения;
	
	ПоляСвёрткиСтрокой      = ПоляКлючаСтрокой + ", " + ПоляЗаполненияСтрокой;
	ПоляСуммированияСтрокой = ПолеОграничения + ?(ЗначениеЗаполнено(ПоляДляПропорциональногоУменьшения), ", ", "") + ПоляДляПропорциональногоУменьшения;
	
	ПоляЗаполненияМассив    = СтрРазделить(ПоляЗаполнения, ", ", Ложь);
	ПоляДляПропорциональногоУменьшенияМассив = СтрРазделить(ПоляДляПропорциональногоУменьшения, ", ", Ложь);
	
	ТаблицаБазаТекущая = ТаблицаБаза.Скопировать();
	ТаблицаБазаТекущая.Свернуть(ПоляСвёрткиСтрокой, ПолеОграничения);
	
	ТаблицаИсточник    = ТаблицаПриемник.Скопировать();
	ТаблицаПриемник.Очистить();
	
	Для Каждого СтрокаИсточника Из ТаблицаИсточник Цикл
		Если СтрокаИсточника[ПолеОграничения] = 0 Тогда
			// Не заполнять
			Продолжить;
		КонецЕсли;
		
		СтруктураРаспределено = Новый Структура(ПоляСуммированияСтрокой);
		Для Каждого КлючЗначениеРаспределено Из СтруктураРаспределено Цикл
			СтруктураРаспределено.Вставить(КлючЗначениеРаспределено.Ключ, 0);
		КонецЦикла;
		
		СтруктураПоиска = Новый Структура(ПоляКлючаСтрокой);
		ЗаполнитьЗначенияСвойств(СтруктураПоиска, СтрокаИсточника);
		
		СтрокиБазы = ТаблицаБазаТекущая.НайтиСтроки(СтруктураПоиска);
		
		Для Каждого СтрокаБазы Из СтрокиБазы Цикл
			Если СтрокаБазы[ПолеОграничения] = 0 Тогда
				// Заполнение по строке базы завершено
				Продолжить;
			КонецЕсли;
			
			Если СтрокаИсточника[ПолеОграничения] = СтруктураРаспределено[ПолеОграничения] Тогда
				// По строке источника всё заполнено
				Прервать;
			КонецЕсли;
			
			СтрокаПриемника = ТаблицаПриемник.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаПриемника, СтрокаИсточника);
			
			КолВоИсходное = СтрокаИсточника[ПолеОграничения] - СтруктураРаспределено[ПолеОграничения];
			КолВоЦелевое  = Мин(СтрокаБазы[ПолеОграничения], КолВоИсходное);
			
			СтрокаПриемника[ПолеОграничения]       = КолВоЦелевое;
			СтруктураРаспределено[ПолеОграничения] = СтруктураРаспределено[ПолеОграничения] + СтрокаПриемника[ПолеОграничения];
			
			Для Каждого ПолеЗаполнения Из ПоляЗаполненияМассив Цикл
				СтрокаПриемника[ПолеЗаполнения] = СтрокаБазы[ПолеЗаполнения];
			КонецЦикла;
			Если СтрокаИсточника[ПолеОграничения] = СтрокаПриемника[ПолеОграничения] Тогда
				// Пересчет не требуется
				Для Каждого ПолеДляПропроциональногоРасчета Из ПоляДляПропорциональногоУменьшенияМассив Цикл
					СтруктураРаспределено[ПолеДляПропроциональногоРасчета] = СтруктураРаспределено[ПолеДляПропроциональногоРасчета]
						                                                     + СтрокаПриемника[ПолеДляПропроциональногоРасчета];
				КонецЦикла;
			Иначе
				Для Каждого ПолеДляПропроциональногоРасчета Из ПоляДляПропорциональногоУменьшенияМассив Цикл
					Если СтруктураРаспределено[ПолеОграничения] = СтрокаИсточника[ПолеОграничения] Тогда
						// Весь остаток
						ЗначениеПослеРасчета = СтрокаИсточника[ПолеДляПропроциональногоРасчета]
						                       - СтруктураРаспределено[ПолеДляПропроциональногоРасчета];
					Иначе
						// Пропорциональный остаток
						ЗначениеПослеРасчета = СтрокаИсточника[ПолеДляПропроциональногоРасчета] * СтруктураРаспределено[ПолеОграничения]
						                                                                          / СтрокаИсточника[ПолеОграничения]
					                           - СтруктураРаспределено[ПолеДляПропроциональногоРасчета];
					КонецЕсли;
					
					СтрокаПриемника[ПолеДляПропроциональногоРасчета]       = ЗначениеПослеРасчета;
					СтруктураРаспределено[ПолеДляПропроциональногоРасчета] = СтруктураРаспределено[ПолеДляПропроциональногоРасчета]
					                                                         + СтрокаПриемника[ПолеДляПропроциональногоРасчета];
				КонецЦикла;
			КонецЕсли;
			
			СтрокаБазы[ПолеОграничения] = СтрокаБазы[ПолеОграничения] - СтрокаПриемника[ПолеОграничения];
		КонецЦикла;
		
		Если СтрокаИсточника[ПолеОграничения] <> СтруктураРаспределено[ПолеОграничения] Тогда
			// Добавим строку остатка, без изменения полей заполнения
			
			СтрокаПриемника = ТаблицаПриемник.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаПриемника, СтрокаИсточника);
			
			КолВоЦелевое  = СтрокаИсточника[ПолеОграничения] - СтруктураРаспределено[ПолеОграничения];
			
			СтрокаПриемника[ПолеОграничения]       = КолВоЦелевое;
			СтруктураРаспределено[ПолеОграничения] = СтруктураРаспределено[ПолеОграничения] + СтрокаПриемника[ПолеОграничения];
			
			Если СтрокаИсточника[ПолеОграничения] = СтрокаПриемника[ПолеОграничения] Тогда
				// Пересчет не требуется
			Иначе
				Для Каждого ПолеДляПропроциональногоРасчета Из ПоляДляПропорциональногоУменьшенияМассив Цикл
					// Весь остаток
					ЗначениеПослеРасчета = СтрокаИсточника[ПолеДляПропроциональногоРасчета]
					                       - СтруктураРаспределено[ПолеДляПропроциональногоРасчета];
					
					СтрокаПриемника[ПолеДляПропроциональногоРасчета]       = ЗначениеПослеРасчета;
					СтруктураРаспределено[ПолеДляПропроциональногоРасчета] = СтруктураРаспределено[ПолеДляПропроциональногоРасчета]
					                                                         + СтрокаПриемника[ПолеДляПропроциональногоРасчета];
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Определяет является ли объект метаданных ссылкой.
//
// Параметры:
//  МетаданныеОбъекта - МетаданныеОбъекта - Метаданные.
//
// Возвращаемое значение:
//  Булево - если ИСТИНА - является ссылочным объектом метаданных, если ЛОЖЬ - нет.
//
Функция ЭтоМетаданныеСсылки(МетаданныеОбъекта) Экспорт

	Если Метаданные.Справочники.Содержит(МетаданныеОбъекта) Или
		Метаданные.Документы.Содержит(МетаданныеОбъекта) Или
		Метаданные.ПланыСчетов.Содержит(МетаданныеОбъекта) Или
		Метаданные.ПланыВидовРасчета.Содержит(МетаданныеОбъекта) Или
		Метаданные.ПланыВидовХарактеристик.Содержит(МетаданныеОбъекта) Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

#Область Индексы

Процедура ПоместитьЗначениеВИндекс(Индекс, Значение, Ключ1 = Неопределено, Ключ2 = Неопределено, Ключ3 = Неопределено, Ключ4 = Неопределено, Ключ5 = Неопределено) Экспорт
	
	// VELO-732 30.10.2023 pkharchuk@rdv-it.ru  
	
	Если ТипЗнч(Индекс) <> Тип("Соответствие") Тогда
		Возврат;
	КонецЕсли;
	
	Если Ключ1 = Неопределено Тогда
		Возврат;
	ИначеЕсли Ключ2 = Неопределено Тогда
		Индекс[Ключ1] = Значение;
	Иначе
		ПодИндекс = Индекс[Ключ1];
		Если ТипЗнч(ПодИндекс) <> Тип("Соответствие") Тогда
			ПодИндекс = Новый Соответствие;
			Индекс[Ключ1] = ПодИндекс;
		КонецЕсли;
		
		ПоместитьЗначениеВИндекс(ПодИндекс, Значение, Ключ2, Ключ3, Ключ4, Ключ5);
	КонецЕсли;
	
КонецПроцедуры

Функция ЗначениеИндекса(Индекс, Ключ1 = Неопределено, Ключ2 = Неопределено, Ключ3 = Неопределено, Ключ4 = Неопределено, Ключ5 = Неопределено) Экспорт
	
	// VELO-732 30.10.2023 pkharchuk@rdv-it.ru 
	
	Результат = Неопределено;
	
	Если ТипЗнч(Индекс) <> Тип("Соответствие") Тогда
		Результат = Неопределено;
	ИначеЕсли Ключ1 = Неопределено Тогда
		Результат = Неопределено;
	ИначеЕсли Ключ2 = Неопределено Тогда
		Результат = Индекс[Ключ1];
	Иначе
		Результат = ЗначениеИндекса(Индекс[Ключ1], Ключ2, Ключ3, Ключ4, Ключ5);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

Функция ЗапомнитьОшибкуВСообщения(Объект, ИмяОшибки, ТекстОшибки) Экспорт
	
	// VELO-1635 12.02.2024 pshemyakin@rdv-it.ru 
	
	ОшибкиВСообщения = Неопределено;
	
	ТипОбъекта = ТипЗнч(Объект);
	Если ТипОбъекта = Тип("Структура")
		ИЛИ ТипОбъекта = Тип("ДанныеФормыКоллекция") Тогда
	
		Возврат Ложь;
	
	КонецЕсли;
	
	Если Объект.ДополнительныеСвойства.Свойство("ОшибкиВСообщения", ОшибкиВСообщения) Тогда
	
		Если ОшибкиВСообщения.Свойство(ИмяОшибки) Тогда
		
			ОшибкиВСообщения[ИмяОшибки] = ТекстОшибки;
			Возврат Истина;
		
		КонецЕсли;
	
	КонецЕсли;
	
	Возврат Ложь;

КонецФункции

#КонецОбласти

#Область ВспомогательныеПроцедурыФункции

Функция ПреобразоватьТабличныйДокументВТаблицуЗначений(Знач ТабДок) Экспорт
	
	ПоследняяСтрока = ТабДок.ВысотаТаблицы;
	ПоследняяКолонка = ТабДок.ШиринаТаблицы;
	ОбластьЯчеек = ТабДок.Область(1, 1, ПоследняяСтрока, ПоследняяКолонка); 

	ИсточникДанных = Новый ОписаниеИсточникаДанных(ОбластьЯчеек);
	
	ПостроительОтчета = Новый ПостроительОтчета;
	ПостроительОтчета.ИсточникДанных = ИсточникДанных;
	ПостроительОтчета.Выполнить();

	ТЗ = ПостроительОтчета.Результат.Выгрузить();
	
	Возврат ТЗ;
	
КонецФункции

Функция СтрокаВДату(Знач ФорматДаты, Знач ДатаСтрокой, Отказ = Ложь) Экспорт 
	
	Если Не ЗначениеЗаполнено(ДатаСтрокой) Тогда
		Возврат Дата(1,1,1);
	КонецЕсли;
	
	Попытка 
        ё = Формат('00010101', "ДФ=" + ФорматДаты) // - необязательная проверка правильности первого параметра 
    Исключение 
        Отказ = Истина; 
        Возврат '00010101' 
    КонецПопытки; 
	
	Ч = Новый Соответствие; 
    Для ё = 1 По СтрДлина(ФорматДаты) + 7 Цикл 
        Ч[Сред(ФорматДаты + "dMyHhms", ё, 1)] = 0    // - инициализация частей даты 
    КонецЦикла; 
	
	Для ё = 1 По 12 Цикл 
        ДатаСтрокой = СтрЗаменить(ДатаСтрокой, Формат(Дата(1, ё, 1), "ДФ=MMММ"), Формат(ё, "ЧЦ=4; ЧВН=")); // - замена названий месяцев числами 
        ДатаСтрокой = СтрЗаменить(ДатаСтрокой, Формат(Дата(1, ё, 1), "ДФ=MMМ" ), Формат(ё, "ЧЦ=3; ЧВН=")) 
    КонецЦикла; 
	
	Для ё = 1 По СтрДлина(ФорматДаты) Цикл 
        Ч[Сред(ФорматДаты, ё, 1)] = 10 * Ч[Сред(ФорматДаты, ё, 1)] + Найти("123456789", Сред(ДатаСтрокой, ё, 1)); // - накопление частей даты 
        Отказ = Отказ ИЛИ Найти("dMyHhms", Сред(ФорматДаты, ё, 1)) И НЕ Найти("0123456789", Сред(ДатаСтрокой, ё, 1)) // - необязательная проверка на цифры 
    КонецЦикла; 
	
	Ч["y"] = Ч["y"] + ?(Ч["y"] < 50, 2000, ?(Ч["y"] < 100, 1900, 0)); // - дополнение двух цифр года до четырех 
    Попытка 
        Возврат Дата(Ч["y"], Ч["M"], Ч["d"], Ч["H"] + Ч["h"], Ч["m"], Ч["s"]) 
    Исключение 
        Отказ = Истина; 
        Возврат '00010101' 
	КонецПопытки;
	
КонецФункции

#КонецОбласти
